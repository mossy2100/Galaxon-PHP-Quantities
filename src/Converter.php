<?php

declare(strict_types=1);

namespace Galaxon\Quantities;

use Galaxon\Core\Arrays;
use LogicException;
use ValueError;

/**
 * Manages unit conversions for a measurement type.
 *
 * This class handles:
 * - Validation of base units, prefixes, and conversion definitions
 * - Generation of prefixed units (e.g., 'km', 'mg', 'ns')
 * - Storage and retrieval of conversion factors between units
 * - Automatic discovery of indirect conversion paths via graph traversal
 * - Prefix algebra for converting between prefixed units
 *
 * The conversion system works by:
 * 1. Storing direct conversions provided in the configuration
 * 2. Automatically inferring additional conversions through:
 *    - Inversion (if a→b exists, compute b→a)
 *    - Composition (if a→c and c→b exist, compute a→b)
 * 3. Applying prefix adjustments when requested units have prefixes
 *
 * All conversions use the linear transformation formula: y = m*x where m is the multiplier.
 *
 * Error tracking: Each conversion has an error score based on numerical precision.
 * The system prefers shorter conversion paths with lower cumulative error.
 */
class Converter
{
    // region Properties

    /**
     * Dimension code for the converter.
     *
     * @var string
     */
    private(set) string $dimension;

    /**
     * Unprefixed unit term symbols for this converter. These will be our array keys.
     *
     * @var array<string, string>
     */
    private(set) array $unitTermSymbols;

    /**
     * Conversion matrix storing known conversions between unit terms.
     *
     * Structure: $conversions[srcUnitTermSymbol][destUnitTermSymbol] = Conversion
     * Includes both explicitly defined conversions and generated ones.
     *
     * @var array<string, array<string, Conversion>>
     */
    private array $conversions = [];

    // endregion

    // region Static properties

    /**
     * All the Converters created so far, keyed by dimension.
     *
     * @var array<string, Converter>
     */
    private static array $instances;

    // endregion

    // region Constructor

    /**
     * Constructor.
     *
     * Initializes the UnitConverter instance for a given dimension.
     *
     * @param string $dimension Dimension code (e.g. 'L').
     * @throws ValueError If the dimension is invalid.
     */
    private function __construct(string $dimension)
    {
        // Check the dimension is valid.
        if (!Dimensions::isValid($dimension)) {
            throw new ValueError("Invalid dimension '$dimension'.");
        }

        // Store the dimension code.
        $this->dimension = $dimension;

        // Get the valid unit term symbols for this dimension. These will be our array keys.
        $this->unitTermSymbols = self::getUnitSymbolsByDimension($dimension);

        // Load the initial conversions into the matrix.
        $this->resetConversions();
    }

    /**
     * Get the Converter instance for a given dimension.
     *
     * @param string $dimension Dimension code (e.g. 'L').
     * @return self
     */
    public static function get(string $dimension): self
    {
        // Make sure a Converter for this dimension has been created.
        if (!isset(self::$instances[$dimension])) {
            self::$instances[$dimension] = new self($dimension);
        }

        return self::$instances[$dimension];
    }

    // endregion

    // region Extraction methods

    /**
     * Look up the Unit object corresponding to a unit symbol.
     *
     * @param string $unit The unit symbol.
     * @return UnitTerm The Unit object corresponding to the provided string.
     * @throws ValueError If the unit is invalid.
     */
    public function getUnit(string $unit): UnitTerm
    {
        $this->checkIsValidUnitTermSymbol($unit);
        return $this->unitTermSymbols[$unit];
    }

    /**
     * Find the conversion between two unit terms.
     *
     * TODO Update to handle units with exponents, e.g. say we want a conversion from m3 to yd3.
     * We can look for one that exists directly between m3 and yd3, or, if that fails, we can look for a conversion from
     * m to yd, then apply the exponent to the result.
     *
     * Returns the Conversion object representing the transformation from source to destination unit.
     * The conversion may be:
     * - Retrieved from cache if previously computed
     * - A unity conversion if units are identical
     * - A prefix-only adjustment if units share the same base
     * - Generated by pathfinding through the conversion matrix
     *
     * Generated conversions are cached for future use.
     *
     * @param string|BaseUnit|UnitTerm $srcUnitTerm The source unit term symbol or instance.
     * @param string|BaseUnit|UnitTerm $destUnitTerm The destination unit term symbol or instance.
     * @return Conversion The conversion transformation.
     * @throws ValueError If either unit is invalid.
     *
     * @example
     *   $conversion = $converter->getConversion('m', 'ft');
     *   $feet = $conversion->apply(10);  // Convert 10 meters to feet
     */
    public function getConversion(string|BaseUnit|UnitTerm $srcUnitTerm, string|BaseUnit|UnitTerm $destUnitTerm): ?Conversion
    {
        // Validate the unit terms.
        $srcUnitTerm = $this->checkIsValidUnitTermSymbol($srcUnitTerm);
        $destUnitTerm = $this->checkIsValidUnitTermSymbol($destUnitTerm);

        // Handle the simple case.
        if ($srcUnitTerm->equal($destUnitTerm)) {
            return new Conversion($this->dimension, $srcUnitTerm, $destUnitTerm, 1);
        }

        // See if we already have this one.
        $conversion = $this->conversions[(string)$srcUnitTerm][(string)$destUnitTerm] ?? null;
        if ($conversion !== null) {
            return $conversion;
        }

        // Extract the unprefixed unit term symbols into convenient variables.
        $src = $srcUnitTerm->unprefixedSymbol;
        $dest = $destUnitTerm->unprefixedSymbol;

        if ($src === $dest) {
            // Converting between two units with the same unprefixed unit. Since we know the unit terms are different,
            // they must have different prefixes; or, one has a prefix and one doesn't.
            // Start with the unity conversion and we'll apply prefixes later.
            $conversion = new Conversion($this->dimension, $src, $dest, 1);
        } elseif (isset($this->conversions[$src][$dest])) {
            // Check if the conversion between unprefixed units is already known.
            $conversion = $this->conversions[$src][$dest];
        } else {
            // Keep generating new conversions until we find the conversion between the derived units, or we run
            // out of options.
            do {
                $result = $this->findNextConversion();
            } while (!isset($this->conversions[$src][$dest]) && $result);

            // If we didn't find the conversion, return null.
            if (!isset($this->conversions[$src][$dest])) {
                return null;
            }

            $conversion = $this->conversions[$src][$dest];
        }

        echo $conversion, "\n";

        // If there are no prefixes, done.
        if ($srcUnitTerm->prefix === null && $destUnitTerm->prefix === null) {
            return $conversion;
        }

        // Apply prefixes.
        $conversion = $conversion->alterPrefixes($srcUnitTerm->prefix, $destUnitTerm->prefix);

        echo $conversion, "\n";

        // Add the new conversion (with prefixed units) to the matrix.
        $this->addConversion($srcUnitTerm, $destUnitTerm, $conversion);

        return $conversion;
    }

    // endregion

    // region Modification methods

    public function addConversion(string|UnitTerm $srcUnitTerm, string|UnitTerm $destUnitTerm, Conversion $conversion): void
    {
        $this->conversions[(string)$srcUnitTerm][(string)$destUnitTerm] = $conversion;
    }

    // endregion

    // region Validation methods

    /**
     * Check if a unit term symbol is valid.
     *
     * @param string $unitTermSymbol The unit term symbol.
     * @return bool True if the unit term symbol is valid.
     */
    public function isValidUnitSymbol(string $unitTermSymbol): bool
    {
        return in_array($unitTermSymbol, $this->unitTermSymbols, true);
    }

    /**
     * Validate a unit term symbol. Return the UnitTerm if valid, and throw an exception if not.
     *
     * @param string|BaseUnit|UnitTerm $unitTerm The unit term symbol or object to validate.
     * @return UnitTerm The validated unit term symbol.
     * @throws ValueError If the unit term symbol is invalid for this Converter.
     */
    public function checkIsValidUnitTermSymbol(string|BaseUnit|UnitTerm $unitTerm): UnitTerm
    {
        $origUnitTermSymbol = (string)$unitTerm;

        // Get the unit term as an object.
        if (is_string($unitTerm)) {
            $unitTerm = UnitTerm::parse($origUnitTermSymbol);
        }
        elseif ($unitTerm instanceof BaseUnit) {
            $unitTerm = new UnitTerm($unitTerm);
        }

        // Get the unprefixed version.
        $unprefixedUnitTerm = $unitTerm->removePrefix();

        // Check the unit term symbol is valid.
        if (!$this->isValidUnitSymbol((string)$unprefixedUnitTerm)) {
            $quotedSymbols = implode(', ', Arrays::quoteValues($this->unitTermSymbols));
            throw new ValueError("Invalid unit term '$origUnitTermSymbol'. Valid symbols (without prefixes) are: $quotedSymbols.");
        }

        return $unitTerm;
    }

    // endregion

    // region Application methods

    /**
     * Convert a numeric value from one unit to another.
     *
     * Validates both unit symbols, retrieves or computes the conversion,
     * and applies it to the value using the formula: y = m*x + k
     *
     * @param float $value The value to convert.
     * @param string|UnitTerm $srcUnitTerm The source unit symbol.
     * @param string|UnitTerm $destUnitTerm The destination unit symbol.
     * @return float The converted value.
     * @throws ValueError If either unit symbol is invalid.
     * @throws LogicException If no conversion path exists between the units.
     *
     * @example
     *   $meters = 100;
     *   $feet = $converter->convert($meters, 'm', 'ft');  // 328.084
     */
    public function convert(float $value, string|UnitTerm $srcUnitTerm, string|UnitTerm $destUnitTerm): float
    {
        // Remember the original unit terms for error reporting.
        $origSrcUnitTerm = (string)$srcUnitTerm;
        $origDestUnitTerm = (string)$destUnitTerm;

        // Check unit terms are valid and get them as objects.
        $srcUnitTerm = $this->checkIsValidUnitTermSymbol($srcUnitTerm);
        $destUnitTerm = $this->checkIsValidUnitTermSymbol($destUnitTerm);

        // Get the conversion.
        $conversion = $this->getConversion($srcUnitTerm, $destUnitTerm);

        // If no conversion was found, throw an exception.
        if ($conversion === null) {
            throw new LogicException("No conversion found between units '$origSrcUnitTerm' and '$origDestUnitTerm'.");
        }

        // Multiply by the conversion factor.
        return $value * $conversion->factor->value;
    }

    // endregion

    // region Helper methods

    /**
     * Rebuild the conversion matrix from conversion definitions.
     *
     * Clears all existing conversions and recreates them from the stored definitions.
     * For prefixed unit conversions, also generates corresponding derived unit conversions needed by the pathfinding
     * algorithm.
     *
     * Called automatically when units or conversions are modified.
     *
     * @return void
     */
    private function resetConversions(): void
    {
        // Clear the conversion matrix.
        $this->conversions = [];

        // Get all the conversions for this dimension.
        $conversions = ConversionData::getConversions($this->dimension);
        foreach ($conversions as $conversion) {
            // Add the conversion to the matrix.
            $this->addConversion($conversion->srcUnitTerm, $conversion->destUnitTerm, $conversion);

            // If prefixes are present, generate the unprefixed conversion and add it to the matrix.
            if ($conversion->srcUnitTerm->prefix !== null || $conversion->destUnitTerm->prefix !== null) {
                $unprefixedSrcUnitTerm = $conversion->srcUnitTerm->removePrefix();
                $unprefixedDestUnitTerm = $conversion->destUnitTerm->removePrefix();
                $unprefixedConversion = $conversion->removePrefixes();
                $this->addConversion($unprefixedSrcUnitTerm, $unprefixedDestUnitTerm, $unprefixedConversion);
            }
        }

        // If the dimension comprises a letter plus an exponent (e.g. 'L3', 'T-1'), search for conversions matching the
        // letter only, then apply the exponent.
        if (($termInfo = Dimensions::parseTerm($this->dimension)) !== null) {
            $conversions = ConversionData::getConversions($termInfo['dimension']);
            foreach ($conversions as $conversion) {

                // Construct the new conversion with the exponent applied.
                $newConversion = new Conversion(
                    $this->dimension,
                    $conversion->srcUnitTerm->applyExponent($termInfo['exponent']),
                    $conversion->destUnitTerm->applyExponent($termInfo['exponent']),
                    $conversion->factor->pow($termInfo['exponent'])
                );

                // Add the new conversion to the matrix.
                $this->addConversion($conversion->srcUnitTerm, $conversion->destUnitTerm, $newConversion);
            }
        }
    }

    /**
     * Private function to help us keep track of the best conversion found so far.
     *
     * @param string $srcUnitTermSymbol
     * @param string $destUnitTermSymbol
     * @param Conversion $newConversion
     * @param float $minErr The least total absolute error of all the Conversions found so far.
     * @param ?array{srcUnit: string, destUnit: string, newConversion: Conversion} $best Details of the best
     * (least error) Conversion found so far.
     * @return void
     */
    private function testNewConversion(
        string $srcUnitTermSymbol,
        string $destUnitTermSymbol,
        Conversion $newConversion,
        float &$minErr,
        ?array &$best
    ): void
    {
        // Let's see if we have a new best.
        if ($newConversion->totalAbsoluteError < $minErr) {
            $minErr = $newConversion->totalAbsoluteError;
            $best = [
                'srcUnitTermSymbol'  => $srcUnitTermSymbol,
                'destUnitTermSymbol' => $destUnitTermSymbol,
                'newConversion'      => $newConversion,
            ];
        }
    }

    /**
     * Generate the next best conversion by traversing the conversion graph.
     *
     * Uses a best-first search strategy to find new conversions by:
     * - Inverting existing conversions (if a→b exists, compute b→a)
     * - Composing conversions through intermediate units (if a→c and c→b exist, compute a→b)
     *
     * Selects the conversion with the lowest error score to add to the matrix.
     * Error scores guide the search toward shorter, more accurate paths.
     *
     * @return bool True if a new conversion was found and added, false if none remain.
     */
    private function findNextConversion(): bool
    {
        // Prep.
        $minErr = PHP_FLOAT_MAX;
        $best = null;

        // Iterate through all possible pairs of unit terms.
        foreach ($this->unitTermSymbols as $src) {
            foreach ($this->unitTermSymbols as $dest) {

                // If we don't need this conversion, or it's already known, continue.
                if ($src === $dest || isset($this->conversions[$src][$dest])) {
                    continue;
                }

                // Look for the inverse conversion.
                if (isset($this->conversions[$dest][$src])) {
                    $newConversion = $this->conversions[$dest][$src]->invert();
                    $this->testNewConversion($src, $dest, $newConversion, $minErr, $best);
                }

                // Look for a conversion opportunity via an intermediate unit.
                /** @var string $mid */
                foreach ($this->unitTermSymbols as $mid) {

                    // The intermediate unit must be different from the source and destination units.
                    if ($src === $mid || $dest === $mid) {
                        continue;
                    }

                    // Get conversions between the source, destination, and intermediate unit.
                    $srcToCommon = $this->conversions[$src][$mid] ?? null;
                    $midToSrc = $this->conversions[$mid][$src] ?? null;
                    $destToCommon = $this->conversions[$dest][$mid] ?? null;
                    $midToDest = $this->conversions[$mid][$dest] ?? null;

                    // Combine source->mid with mid->dest (sequential).
                    if ($srcToCommon !== null && $midToDest !== null) {
                        $newConversion = $srcToCommon->combineSequential($midToDest);
                        $this->testNewConversion($src, $dest, $newConversion, $minErr, $best);
                    }

                    // Combine source->mid with dest->mid (convergent).
                    if ($srcToCommon !== null && $destToCommon !== null) {
                        $newConversion = $srcToCommon->combineConvergent($destToCommon);
                        $this->testNewConversion($src, $dest, $newConversion, $minErr, $best);
                    }

                    // Combine mid->source with mid->dest (divergent).
                    if ($midToSrc !== null && $midToDest !== null) {
                        $newConversion = $midToSrc->combineDivergent($midToDest);
                        $this->testNewConversion($src, $dest, $newConversion, $minErr, $best);
                    }

                    // Combine mid->source with dest->mid (opposite).
                    if ($midToSrc !== null && $destToCommon !== null) {
                        $newConversion = $midToSrc->combineOpposite($destToCommon);
                        $this->testNewConversion($src, $dest, $newConversion, $minErr, $best);
                    }
                }
            }
        }

        if ($best !== null) {
            // Remember the best conversion we found for this scan.
            $this->addConversion($best['srcUnitTermSymbol'], $best['destUnitTermSymbol'], $best['newConversion']);

            // Report that we found one.
            return true;
        }

        return false;
    }

    /**
     * Get all the primary unit symbols matching a given dimension code.
     * These must be the primary symbols only, because they're for array keys.
     * Also, they should not have prefixes.
     *
     * @param string $dimension The dimension code.
     * @return array The unit symbols matching the dimension.
     */
    public static function getUnitSymbolsByDimension(string $dimension): array
    {
        $symbols = [];
        $units = UnitData::getByDimension($dimension);
        foreach ($units as $unit) {
            $symbols[] = $unit->symbol;
        }

        // If we have a letter plus an exponent, search for units matching the letter only, and add the exponent.
        if (($termInfo = Dimensions::parseTerm($dimension)) !== null) {
            $units = UnitData::getByDimension($termInfo['dimension']);
            foreach ($units as $unit) {
                $symbols[] = $unit->symbol . $termInfo['exponent'];
            }
        }

        return $symbols;
    }


    /**
     * Generate all possible conversions by exhaustive graph traversal.
     *
     * Repeatedly calls generateNextConversion() until no more conversions can be found.
     * This creates a complete conversion matrix for all unit pairs.
     *
     * Note: This method is primarily for debugging. Normal operation uses lazy generation
     * in getConversion(), which is more efficient as it only computes needed conversions.
     *
     * @return void
     * @codeCoverageIgnore
     */
    public function completeMatrix(): void
    {
        do {
            $result = $this->findNextConversion();
        } while ($result);
    }

    /**
     * Check if the conversion matrix is complete (all conversions between derived units are known).
     *
     * @return bool True if complete, false otherwise.
     * @codeCoverageIgnore
     */
    public function isMatrixComplete(): bool
    {
        foreach ($this->unitTermSymbols as $srcUnitTerm) {
            foreach ($this->unitTermSymbols as $destUnitTerm) {
                if (!isset($this->conversions[$srcUnitTerm][$destUnitTerm])) {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * Print the conversion matrix for debugging purposes.
     *
     * @return void
     * @codeCoverageIgnore
     */
    public function printMatrix(): void
    {
        $colWidth = 20;
        $nUnits = count($this->unitTermSymbols);
        $line = '+------+' . str_repeat(str_repeat('-', $colWidth) . '+', $nUnits) . "\n";

        echo $line;
        echo '|      |';
        foreach ($this->unitTermSymbols as $unitTermSymbol) {
            echo str_pad($unitTermSymbol, $colWidth, ' ', STR_PAD_BOTH) . '|';
        }
        echo "\n";
        echo $line;

        foreach ($this->unitTermSymbols as $srcUnitTermSymbol) {
            echo '|' . str_pad($srcUnitTermSymbol, 6) . '|';
            foreach ($this->unitTermSymbols as $destUnitTermSymbol) {
                if (isset($this->conversions[$srcUnitTermSymbol][$destUnitTermSymbol])) {
                    $mul = $this->conversions[$srcUnitTermSymbol][$destUnitTermSymbol]->factor->value;
                    $sMul = sprintf('%.10g', $mul);
                    echo str_pad($sMul, $colWidth);
                } else {
                    echo str_pad('?', $colWidth);
                }
                echo '|';
            }
            echo "\n";
        }

        echo $line;
    }

    /**
     * Dump the conversion matrix contents for debugging purposes.
     *
     * @return void
     * @codeCoverageIgnore
     */
    public function dumpMatrix(): void
    {
        echo "\n";
        echo "CONVERSION MATRIX\n";
        foreach ($this->unitTermSymbols as $srcUnitTermSymbol) {
            foreach ($this->unitTermSymbols as $destUnitTermSymbol) {
                echo $this->conversions[$srcUnitTermSymbol][$destUnitTermSymbol], "\n";
            }
        }
        echo "\n";
        echo "\n";
    }

    // endregion
}
