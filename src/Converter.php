<?php

declare(strict_types=1);

namespace Galaxon\Quantities;

use DomainException;
use Galaxon\Core\Exceptions\FormatException;
use Galaxon\Quantities\Registry\ConversionRegistry;
use Galaxon\Quantities\Registry\DimensionRegistry;
use Galaxon\Quantities\Registry\QuantityTypeRegistry;
use Galaxon\Quantities\Registry\UnitRegistry;
use LogicException;

/**
 * Manages unit conversions for a measurement type.
 *
 * This class handles:
 * - Validation of base units, prefixes, and conversion definitions
 * - Storage and retrieval of conversion factors between units
 * - Automatic discovery of indirect conversion paths via graph traversal
 * - Prefix algebra for converting between prefixed units
 *
 * The conversion system works by:
 * 1. Storing direct conversions provided in the configuration
 * 2. Automatically inferring additional conversions through:
 *    - Inversion (if a→b exists, compute b→a)
 *    - Composition (if a→c and c→b exist, compute a→b)
 * 3. Applying prefix adjustments when requested units have prefixes
 *
 * All conversions use the linear transformation formula: y = m*x where m is the multiplier.
 *
 * Error tracking: Each conversion has an error score based on numerical precision.
 * The system prefers shorter conversion paths with lower cumulative error.
 */
class Converter
{
    // region Properties

    /**
     * Dimension code for the converter.
     *
     * @var string
     */
    private(set) string $dimension;

    /**
     * Unprefixed units for this converter.
     *
     * @var array<string, DerivedUnit>
     */
    private(set) array $units = [];

    // endregion

    // region Static properties

    /**
     * All the Converters created so far, keyed by dimension.
     *
     * @var array<string, Converter>
     */
    private static array $instances;

    // endregion

    // region Constructor

    /**
     * Constructor.
     *
     * Initializes the Converter instance for a given dimension.
     *
     * @param string $dimension Dimension code (e.g. 'L', 'MLT-2').
     * @throws FormatException If the dimension code is invalid.
     * @throws DomainException If any conversion definitions are invalid.
     */
    private function __construct(string $dimension)
    {
        // Check the dimension is valid.
        if (!DimensionRegistry::isValid($dimension)) {
            throw new FormatException("Invalid dimension code '$dimension'.");
        }

        // Store the dimension code.
        $this->dimension = $dimension;

        // Load units from the registered conversions for this dimension.
        $conversionsBySrc = ConversionRegistry::getByDimension($dimension);
        foreach ($conversionsBySrc as $conversionsByDest) {
            foreach ($conversionsByDest as $conversion) {
                $this->addUnit($conversion->srcUnit->removePrefixes());
                $this->addUnit($conversion->destUnit->removePrefixes());
            }
        }
    }

    // endregion

    // region Static methods

    /**
     * Get the Converter instance for a given dimension.
     *
     * @param string $dimension Dimension code (e.g. 'L').
     * @return self
     * @throws DomainException
     */
    public static function getByDimension(string $dimension): self
    {
        // Make sure a Converter for this dimension has been created.
        if (!isset(self::$instances[$dimension])) {
            self::$instances[$dimension] = new self($dimension);
        }

        return self::$instances[$dimension];
    }

    // endregion

    // region Extraction methods

    /**
     * Find the conversion between two unit terms.
     *
     * Returns the Conversion object representing the transformation from source to destination unit term.
     * The conversion may be:
     * - Retrieved from the ConversionRegistry if previously computed
     * - A unity conversion if units are identical
     * - A prefix-only adjustment if units share the same base
     * - Generated by pathfinding through the conversion matrix
     *
     * Generated conversions are cached for future use.
     *
     * @param string|UnitInterface $srcUnit The source unit.
     * @param string|UnitInterface $destUnit The destination unit.
     * @return ?Conversion The conversion transformation or null if none found.
     * @throws DomainException If either unit term is invalid.
     *
     * @example
     *   $conversion = $converter->getConversion('m', 'ft');
     */
    public function getConversion(string|UnitInterface $srcUnit, string|UnitInterface $destUnit): ?Conversion
    {
        // Validate the units and convert to DerivedUnit objects.
        $srcUnit = $this->validateUnit($srcUnit);
        $destUnit = $this->validateUnit($destUnit);

        // Handle the simple case.
        if ($srcUnit->equal($destUnit)) {
            return new Conversion($srcUnit, $destUnit, 1.0);
        }

        // Make sure both unit terms (unprefixed) are in the Converter.
        $unprefixedSrcUnit = $srcUnit->removePrefixes();
        $unprefixedDestUnit = $destUnit->removePrefixes();
        $this->addUnit($unprefixedSrcUnit);
        $this->addUnit($unprefixedDestUnit);

        // See if we already have this one.
        $conversion = ConversionRegistry::get($this->dimension, $srcUnit->asciiSymbol, $destUnit->asciiSymbol);
        if ($conversion !== null) {
            return $conversion;
        }

        // Find the conversion between unprefixed units.
        $dim = $this->dimension;
        $src = $unprefixedSrcUnit->asciiSymbol;
        $dest = $unprefixedDestUnit->asciiSymbol;

        // If the units without prefixes are the same, create the identity conversion. Prefixes will be added later.
        if ($src === $dest) {
            // TODO Figure out how to apply source unit prefixes to a DerivedUnit which may have multiple terms.
            return new Conversion($unprefixedSrcUnit, $unprefixedDestUnit, 1.0)
                ->alterPrefixes($srcUnit->prefix, $destUnit->prefix);
        }

        // Generate new conversions until we get a match, or we're out of options.
        do {
            $result = $this->findNextConversion();
        } while (!ConversionRegistry::has($dim, $src, $dest) && $result);

        // Get the unprefixed conversion. Return null if not found.
        $unprefixedConversion = ConversionRegistry::get($dim, $src, $dest);
        if ($unprefixedConversion === null) {
            return null;
        }

        // Apply prefixes if necessary.
        if (!$srcUnit->equal($unprefixedSrcUnit) || !$destUnit->equal($unprefixedDestUnit)) {
            $conversion = $unprefixedConversion->alterPrefixes($srcUnit->prefix, $destUnit->prefix);

            // Add the new prefixed conversion to the Converter.
            ConversionRegistry::add($conversion);

            // Return it.
            return $conversion;
        }

        // No prefixes; return the unprefixed conversion.
        return $unprefixedConversion;
    }

    /**
     * Get the conversion factor between two unit terms.
     *
     * @param string|UnitInterface $srcUnit The source unit.
     * @param string|UnitInterface $destUnit The destination unit.
     * @return ?float The conversion factor or null if not found.
     * @throws DomainException If either unit term is invalid.
     */
    public function getConversionFactor(string|UnitInterface $srcUnit, string|UnitInterface $destUnit): ?float
    {
        return $this->getConversion($srcUnit, $destUnit)?->factor->value;
    }

    // endregion

    // region Validation methods

    /**
     * Validate a string or object representing a unit.
     *
     * Returns the validated DerivedUnit object if valid, and throws an exception if not.
     *
     * @param string|UnitInterface $value The unit value to validate.
     * @return DerivedUnit The validated DerivedUnit object equivalent to the provided parameter.
     * @throws DomainException If the symbol is invalid or the unit has the wrong dimension for this Converter.
     */
    public function validateUnit(string|UnitInterface $value): DerivedUnit
    {
        // Get the unit term as a DerivedUnit object.
        $unit = DerivedUnit::toDerivedUnit($value);

        // Check the unit term has the right dimension.
        if ($unit->dimension !== $this->dimension) {
            $qtyType = QuantityTypeRegistry::getByDimension($this->dimension);
            $error = $qtyType === null
                ? "The unit dimension '$unit->dimension' does not match the converter dimension '$this->dimension'."
                : "The unit '$unit->asciiSymbol' is invalid for $qtyType->name quantities.";
            throw new DomainException($error);
        }

        return $unit;
    }

    // endregion

    // region Operations

    /**
     * Convert a numeric value from one unit to another.
     *
     * Validates both unit symbols, retrieves or computes the conversion, and applies it to the value using the formula
     * y = m*x
     *
     * @param float $value The value to convert.
     * @param string|UnitInterface $srcUnit The source unit.
     * @param string|UnitInterface $destUnit The destination unit.
     * @return float The converted value.
     * @throws DomainException If either unit symbol is invalid.
     * @throws LogicException If no conversion path exists between the units.
     *
     * @example
     *   $meters = 100;
     *   $feet = $converter->convert($meters, 'm', 'ft');  // 328.084
     */
    public function convert(float $value, string|UnitInterface $srcUnit, string|UnitInterface $destUnit): float
    {
        // Get the conversion.
        $conversion = $this->getConversion($srcUnit, $destUnit);

        // If no conversion was found, throw an exception.
        if ($conversion === null) {
            throw new LogicException("No conversion found between units '$srcUnit' and '$destUnit'.");
        }

        // Multiply by the conversion factor.
        return $value * $conversion->factor->value;
    }

    // endregion

    // region Helper methods

    /**
     * Check if the converter already has a unit.
     *
     * @param DerivedUnit $derivedUnit
     * @return bool
     */
    private function hasUnit(DerivedUnit $derivedUnit): bool
    {
        return isset($this->units[$derivedUnit->asciiSymbol]);
    }

    /**
     * Add the unit.
     *
     * @param DerivedUnit $derivedUnit The unit to add.
     */
    private function addUnit(DerivedUnit $derivedUnit): void
    {
        $this->units[$derivedUnit->asciiSymbol] = $derivedUnit;
    }

    /**
     * Private function to help us keep track of the best conversion found so far.
     *
     * @param Conversion $newConversion
     * @param float $minErr The least relative error of all the Conversions found so far.
     * @param ?Conversion $best The conversion with the least relative error found so far.
     * @return void
     */
    private function testNewConversion(Conversion $newConversion, float &$minErr, ?Conversion &$best): void
    {
        // Let's see if we have a new best.
        if ($newConversion->factor->relativeError < $minErr) {
            $minErr = $newConversion->factor->relativeError;
            $best = $newConversion;
        }
    }

    private static function getConversionByExponentiation(DerivedUnit $srcUnit, DerivedUnit $destUnit): ?Conversion
    {
        // Get the max possible divisor to minimise the number of loops.
        $max = max($srcUnit->maxAbsExp(), $destUnit->maxAbsExp());

        $allDivisible = false;

        // Check if all the unit terms are divisible by an integer.
        for ($exp = $max; $exp >= 2; $exp--) {
            $allDivisible = true;

            foreach ($srcUnit->unitTerms as $unitTerm) {
                if ($unitTerm->exponent % $exp !== 0) {
                    $allDivisible = false;
                    break;
                }
            }

            if (!$allDivisible) {
                continue;
            }

            foreach ($destUnit->unitTerms as $unitTerm) {
                if ($unitTerm->exponent % $exp !== 0) {
                    $allDivisible = false;
                    break;
                }
            }

            if ($allDivisible) {
                break;
            }
        }

        if (!$allDivisible) {
            return null;
        }

        // Find the root of the source and dest units.
        $reducedSrcUnit = $srcUnit->root($exp);
        $reducedDestUnit = $destUnit->root($exp);

        // Try to find a conversion.
        $converter = self::getByDimension($reducedSrcUnit->dimension);
        $conversion = $converter->getConversion($reducedSrcUnit, $reducedDestUnit);

        // Return the conversion raised to the exponent.
        return $conversion?->pow($exp);
    }

    private static function getConversionByTerms(DerivedUnit $srcUnit, DerivedUnit $destUnit): ?Conversion
    {
        // Check number of unit terms match.
        if (count($srcUnit->unitTerms) !== count($destUnit->unitTerms)) {
            return null;
        }

        // Check we have at least 2 unit terms each.
        if (count($srcUnit->unitTerms) < 2) {
            return null;
        }

        // Generate conversion factor by multiplying the factors for each term.
        $srcUnitTerms = array_values($srcUnit->unitTerms);
        $destUnitTerms = array_values($destUnit->unitTerms);
        $factor = new FloatWithError(1);
        foreach ($srcUnitTerms as $i => $srcUnitTerm) {
            $destUnitTerm = $destUnitTerms[$i];

            // Check the dimensions match.
            if ($srcUnitTerm->dimension !== $destUnitTerm->dimension) {
                return null;
            }

            // Get the conversion.
            $converter = self::getByDimension($srcUnitTerm->dimension);
            $conversion = $converter->getConversion($srcUnitTerm, $destUnitTerm);
            if ($conversion === null) {
                return null;
            }

            // Multiply.
            $factor = $factor->mul($conversion->factor);
        }

        return new Conversion($srcUnit, $destUnit, $factor);
    }

    /**
     * Generate the next best conversion by traversing the conversion graph.
     *
     * Uses a best-first search strategy to find new conversions by:
     * - Inverting existing conversions (if a→b exists, compute b→a)
     * - Composing conversions through intermediate units (if a→c and c→b exist, compute a→b)
     *
     * Selects the conversion with the lowest relative error to add to the matrix.
     * Error scores guide the search toward shorter, more accurate paths.
     *
     * @return bool True if a new conversion was found and added, false if none could be found.
     */
    private function findNextConversion(): bool
    {
        // Prep.
        $minErr = PHP_FLOAT_MAX;
        $best = null;
        $dim = $this->dimension;

        // Iterate through all possible pairs of units.
        foreach ($this->units as $srcUnit) {
            foreach ($this->units as $destUnit) {
                $src = $srcUnit->asciiSymbol;
                $dest = $destUnit->asciiSymbol;

                // If we don't need this conversion, or it's already known, continue.
                if ($src === $dest || ConversionRegistry::has($dim, $src, $dest)) {
                    continue;
                }

                // Look for the inverse conversion.
                $inverse = ConversionRegistry::get($dim, $dest, $src);
                if ($inverse !== null) {
                    $newConversion = $inverse->inv();
                    $this->testNewConversion($newConversion, $minErr, $best);
                }

                // Look for a conversion opportunity via an intermediate unit.
                foreach ($this->units as $midUnit) {
                    $mid = $midUnit->asciiSymbol;

                    // The intermediate unit must be different from the source and destination units.
                    if ($src === $mid || $dest === $mid) {
                        continue;
                    }

                    // Get conversions between the source, destination, and intermediate unit.
                    $srcToMid = ConversionRegistry::get($dim, $src, $mid);
                    $midToSrc = ConversionRegistry::get($dim, $mid, $src);
                    $destToMid = ConversionRegistry::get($dim, $dest, $mid);
                    $midToDest = ConversionRegistry::get($dim, $mid, $dest);

                    // Combine source->mid with mid->dest (sequential).
                    if ($srcToMid !== null && $midToDest !== null) {
                        $newConversion = $srcToMid->combineSequential($midToDest);
                        $this->testNewConversion($newConversion, $minErr, $best);
                    }

                    // Combine source->mid with dest->mid (convergent).
                    if ($srcToMid !== null && $destToMid !== null) {
                        $newConversion = $srcToMid->combineConvergent($destToMid);
                        $this->testNewConversion($newConversion, $minErr, $best);
                    }

                    // Combine mid->source with mid->dest (divergent).
                    if ($midToSrc !== null && $midToDest !== null) {
                        $newConversion = $midToSrc->combineDivergent($midToDest);
                        $this->testNewConversion($newConversion, $minErr, $best);
                    }

                    // Combine mid->source with dest->mid (opposite).
                    if ($midToSrc !== null && $destToMid !== null) {
                        $newConversion = $midToSrc->combineOpposite($destToMid);
                        $this->testNewConversion($newConversion, $minErr, $best);
                    }
                }

                // Look for a conversion by exponentiation.
                $newConversion = self::getConversionByExponentiation($srcUnit, $destUnit);
                if ($newConversion !== null) {
                    $this->testNewConversion($newConversion, $minErr, $best);
                }

                // Look for a conversion by multiple unit terms.
                $newConversion = self::getConversionByTerms($srcUnit, $destUnit);
                if ($newConversion !== null) {
                    $this->testNewConversion($newConversion, $minErr, $best);
                }
            }
        }

        if ($best !== null) {
            // Remember the best conversion we found for this scan.
            ConversionRegistry::add($best);
//            echo $best, PHP_EOL;

            // Report we found one.
            return true;
        }

        return false;
    }

    /**
     * Get all the unprefixed unit symbols matching the dimension code.
     *
     * These are ASCII symbols because they're for array keys.
     *
     * @return list<string> The unit symbols matching the dimension.
     * @throws DomainException
     */
    private function getUnitSymbolsByDimension(): array
    {
        $symbols = [];
        $units = UnitRegistry::getByDimension($this->dimension);
        foreach ($units as $unit) {
            $symbols[] = $unit->asciiSymbol;
        }

        // If we have a letter plus an exponent greater than 1 (e.g. L2, L3), search for units matching the letter
        // and append the exponent.
        $dimTerms = DimensionRegistry::explode($this->dimension);
        if (count($dimTerms) === 1) {
            $dim = array_key_first($dimTerms);
            $exp = $dimTerms[$dim];
            if ($exp !== 1) {
                $units = UnitRegistry::getByDimension($dim);
                foreach ($units as $unit) {
                    $symbols[] = $unit->asciiSymbol . $exp;
                }
            }
        }

        return $symbols;
    }

    // endregion

    // region Debugging methods

    /**
     * Print the conversion matrix for debugging purposes.
     *
     * @return void
     * @codeCoverageIgnore
     */
    public function printMatrix(): void
    {
        $colWidth = 20;
        $nUnits = count($this->units);
        $line = '+------+' . str_repeat(str_repeat('-', $colWidth) . '+', $nUnits) . "\n";

        echo $line;
        echo '|      |';
        foreach ($this->units as $unitTerm) {
            echo str_pad($unitTerm->asciiSymbol, $colWidth, ' ', STR_PAD_BOTH) . '|';
        }
        echo "\n";
        echo $line;

        foreach ($this->units as $srcUnit) {
            echo '|' . str_pad($srcUnit->asciiSymbol, 6) . '|';
            foreach ($this->units as $destUnit) {
                $conversion = ConversionRegistry::get($this->dimension, $srcUnit->asciiSymbol, $destUnit->asciiSymbol);

                if ($conversion !== null) {
                    $mul = $conversion->factor->value;
                    $sMul = sprintf('%.10g', $mul);
                    echo str_pad($sMul, $colWidth);
                } elseif ($srcUnit->asciiSymbol === $destUnit->asciiSymbol) {
                    echo str_pad('1', $colWidth);
                } else {
                    echo str_pad('?', $colWidth);
                }

                echo '|';
            }
            echo "\n";
        }

        echo $line;
    }

    // endregion
}
