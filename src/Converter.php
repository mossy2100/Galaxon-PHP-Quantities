<?php

declare(strict_types=1);

namespace Galaxon\Quantities;

use DomainException;
use Galaxon\Core\Arrays;
use InvalidArgumentException;
use LogicException;

/**
 * Manages unit conversions for a measurement type.
 *
 * This class handles:
 * - Validation of base units, prefixes, and conversion definitions
 * - Storage and retrieval of conversion factors between units
 * - Automatic discovery of indirect conversion paths via graph traversal
 * - Prefix algebra for converting between prefixed units
 *
 * The conversion system works by:
 * 1. Storing direct conversions provided in the configuration
 * 2. Automatically inferring additional conversions through:
 *    - Inversion (if a→b exists, compute b→a)
 *    - Composition (if a→c and c→b exist, compute a→b)
 * 3. Applying prefix adjustments when requested units have prefixes
 *
 * All conversions use the linear transformation formula: y = m*x where m is the multiplier.
 *
 * Error tracking: Each conversion has an error score based on numerical precision.
 * The system prefers shorter conversion paths with lower cumulative error.
 */
class Converter
{
    // region Properties

    /**
     * Dimension code for the converter.
     *
     * @var string
     */
    private(set) string $dimension;

    /**
     * Unprefixed unit terms for this converter.
     *
     * @var list<UnitTerm>
     */
    private(set) array $unitTerms = [];

    /**
     * Conversion matrix storing known conversions between unit terms.
     *
     * Structure: $conversions[srcUnitTermSymbol][destUnitTermSymbol] = Conversion
     * Includes both explicitly defined conversions and generated ones.
     *
     * @var array<string, array<string, Conversion>>
     */
    private array $conversions = [];

    // endregion

    // region Static properties

    /**
     * All the Converters created so far, keyed by dimension.
     *
     * @var array<string, Converter>
     */
    private static array $instances;

    // endregion

    // region Constructor

    /**
     * Constructor.
     *
     * Initializes the Converter instance for a given dimension.
     *
     * @param string $dimension Dimension code (e.g. 'L').
     * @throws DomainException If the dimension is invalid.
     */
    private function __construct(string $dimension)
    {
        // Check the dimension is valid.
        if (!Dimensions::isValid($dimension)) {
            throw new DomainException("Invalid dimension '$dimension'.");
        }

        // Store the dimension code.
        $this->dimension = $dimension;

        // Load the predefined conversions into the matrix.
        $this->reloadConversions();
    }

    // endregion

    // region Static methods

    /**
     * Get the Converter instance for a given dimension.
     *
     * @param string $dimension Dimension code (e.g. 'L').
     * @return self
     * @throws DomainException
     */
    public static function getByDimension(string $dimension): self
    {
        // Make sure a Converter for this dimension has been created.
        if (!isset(self::$instances[$dimension])) {
            self::$instances[$dimension] = new self($dimension);
        }

        return self::$instances[$dimension];
    }

    // endregion

    // region Extraction methods

    /**
     * Find the conversion between two unit terms.
     *
     * Returns the Conversion object representing the transformation from source to destination unit.
     * The conversion may be:
     * - Retrieved from cache if previously computed
     * - A unity conversion if units are identical
     * - A prefix-only adjustment if units share the same base
     * - Generated by pathfinding through the conversion matrix
     *
     * Generated conversions are cached for future use.
     *
     * @param string|Unit|UnitTerm $srcUnitTerm The source unit term symbol or instance.
     * @param string|Unit|UnitTerm $destUnitTerm The destination unit term symbol or instance.
     * @return ?Conversion The conversion transformation or null if none found.
     * @throws DomainException If either unit term is invalid.
     *
     * @example
     *   $conversion = $converter->getConversion('m', 'ft');
     */
    public function getConversion(string|Unit|UnitTerm $srcUnitTerm, string|Unit|UnitTerm $destUnitTerm): ?Conversion
    {
        // Validate the unit terms.
        $srcUnitTerm = $this->validateUnitTerm($srcUnitTerm);
        $destUnitTerm = $this->validateUnitTerm($destUnitTerm);

        // Handle the simple case.
        if ($srcUnitTerm->equal($destUnitTerm)) {
            return new Conversion($srcUnitTerm, $destUnitTerm, 1.0);
        }

        // Make sure both unit terms (unprefixed) are in the Converter.
        $this->addUnitTerm($srcUnitTerm);
        $this->addUnitTerm($destUnitTerm);

        // See if we already have this one.
        $conversion = $this->conversions[$srcUnitTerm->symbol][$destUnitTerm->symbol] ?? null;
        if ($conversion !== null) {
            return $conversion;
        }

        // Find the conversion between unprefixed units.
        // Get the unprefixed symbols for convenience.
        $src = $srcUnitTerm->unprefixedSymbol;
        $dest = $destUnitTerm->unprefixedSymbol;

        // If the units without prefixes are the same, create the identity conversion. Prefixes will be added later.
        if ($src === $dest) {
            $unitTerm = $srcUnitTerm->removePrefix();
            return new Conversion($unitTerm, $unitTerm, 1.0)
                ->alterPrefixes($srcUnitTerm->prefix, $destUnitTerm->prefix);
        }

        // Generate new conversions until we get a match, or we're out of options.
        do {
            $result = $this->findNextConversion();
        } while (!isset($this->conversions[$src][$dest]) && $result);

        // If we didn't find one, we're done.
        if (!isset($this->conversions[$src][$dest])) {
            return null;
        }

        $unprefixedConversion = $this->conversions[$src][$dest];

        // Apply prefixes if necessary.
        if ($srcUnitTerm->prefix !== null || $destUnitTerm->prefix !== null) {
            $conversion = $unprefixedConversion->alterPrefixes($srcUnitTerm->prefix, $destUnitTerm->prefix);

            // Add the new prefixed conversion to the Converter.
            $this->addConversion($conversion);

            // Return it.
            return $conversion;
        }

        // No prefixes; return the unprefixed conversion.
        return $unprefixedConversion;
    }

    /**
     * Get the conversion factor between two unit terms.
     *
     * @param string|Unit|UnitTerm $srcUnitTerm The source unit term symbol or instance.
     * @param string|Unit|UnitTerm $destUnitTerm The destination unit term symbol or instance.
     * @return ?float The conversion factor or null if not found.
     * @throws DomainException If either unit term is invalid.
     */
    public function getConversionFactor(string|Unit|UnitTerm $srcUnitTerm, string|Unit|UnitTerm $destUnitTerm): ?float
    {
        return $this->getConversion($srcUnitTerm, $destUnitTerm)?->factor->value;
    }

    // endregion

    // region Modification methods

    /**
     * Add a new conversion to the matrix.
     *
     * @param Conversion $conversion
     * @return void
     */
    public function addConversion(Conversion $conversion): void
    {
        // Check the array key for source term exists.
        if (!array_key_exists($conversion->srcUnitTerm->symbol, $this->conversions)) {
            $this->conversions[$conversion->srcUnitTerm->symbol] = [];
        }

        // Add the conversion to the matrix.
        $this->conversions[$conversion->srcUnitTerm->symbol][$conversion->destUnitTerm->symbol] = $conversion;
    }

    // endregion

    // region Validation methods

    /**
     * Validate a string or object representing a unit term.
     *
     * Returns the validated UnitTerm object if valid, and throws an exception if not.
     *
     * @param string|Unit|UnitTerm $value The unit term equivalent value to validate.
     * @return UnitTerm The validated unit term.
     * @throws DomainException If the unit term value is invalid for this Converter.
     * @throws InvalidArgumentException
     */
    public function validateUnitTerm(string|Unit|UnitTerm $value): UnitTerm
    {
        // Get the unit term as a UnitTerm object.
        $unitTerm = UnitTerm::toUnitTerm($value);

        // Check the unit term has the right dimension.
        if ($unitTerm->dimension !== $this->dimension) {
            $quotedSymbols = implode(', ', Arrays::quoteValues($this->getUnitSymbolsByDimension()));
            throw new DomainException(
                "Invalid unit term '$value'. Valid symbols (without prefixes) are: $quotedSymbols."
            );
        }

        return $unitTerm;
    }

    // endregion

    // region Operations

    /**
     * Convert a numeric value from one unit to another.
     *
     * Validates both unit symbols, retrieves or computes the conversion, and applies it to the value using the formula
     * y = m*x
     *
     * @param float $value The value to convert.
     * @param string|UnitTerm $srcUnitTerm The source unit symbol.
     * @param string|UnitTerm $destUnitTerm The destination unit symbol.
     * @return float The converted value.
     * @throws DomainException If either unit symbol is invalid.
     * @throws LogicException If no conversion path exists between the units.
     *
     * @example
     *   $meters = 100;
     *   $feet = $converter->convert($meters, 'm', 'ft');  // 328.084
     */
    public function convert(float $value, string|UnitTerm $srcUnitTerm, string|UnitTerm $destUnitTerm): float
    {
        // Remember the original unit terms for error reporting.
        $origSrcUnitTerm = (string)$srcUnitTerm;
        $origDestUnitTerm = (string)$destUnitTerm;

        // Check unit terms are valid and get them as objects.
        $srcUnitTerm = $this->validateUnitTerm($srcUnitTerm);
        $destUnitTerm = $this->validateUnitTerm($destUnitTerm);

        // Get the conversion.
        $conversion = $this->getConversion($srcUnitTerm, $destUnitTerm);

        // If no conversion was found, throw an exception.
        if ($conversion === null) {
            throw new LogicException("No conversion found between units '$origSrcUnitTerm' and '$origDestUnitTerm'.");
        }

        // Multiply by the conversion factor.
        return $value * $conversion->factor->value;
    }

    // endregion

    // region Helper methods

    private function hasUnitTerm(UnitTerm $unitTerm): bool
    {
        $fnMatch = static fn (UnitTerm $unitTerm2): bool => $unitTerm2->equal($unitTerm);
        return array_find($this->unitTerms, $fnMatch) !== null;
    }

    private function addUnitTerm(UnitTerm $unitTerm): void
    {
        $unprefixedUnitTerm = $unitTerm->removePrefix();
        if (!$this->hasUnitTerm($unprefixedUnitTerm)) {
            $this->unitTerms[] = $unprefixedUnitTerm;
        }
    }

    /**
     * Rebuild the conversion matrix from conversion definitions.
     *
     * Loads conversions from the QuantityType class for this dimension (if one exists).
     * For conversions with prefixed units, also generates corresponding unprefixed unit conversions
     * needed by the conversion-finding algorithm.
     *
     * @return void
     */
    private function reloadConversions(): void
    {
        // Clear the conversion matrix.
        $this->conversions = [];

        // Get the QuantityType class for this dimension.
        $data = QuantityTypes::get($this->dimension);
        $class = $data['class'] ?? null;

        // If no class or the class doesn't have getConversions(), nothing to do.
        if ($class === null || !method_exists($class, 'getConversions')) {
            return;
        }

        // Load conversions from the class.
        /** @var list<array{string, string, float}> $conversionList */
        $conversionList = $class::getConversions();

        foreach ($conversionList as [$srcSymbol, $destSymbol, $factor]) {
            $conversion = new Conversion($srcSymbol, $destSymbol, $factor);

            // Collect unit terms (unprefixed).
            $this->addUnitTerm($conversion->srcUnitTerm);
            $this->addUnitTerm($conversion->destUnitTerm);

            // Add the conversion to the matrix.
            $this->addConversion($conversion);

            // If prefixes are present, generate the unprefixed conversion and add it to the matrix also.
            // This can help find other conversions.
            if ($conversion->srcUnitTerm->prefix !== null || $conversion->destUnitTerm->prefix !== null) {
                $this->addConversion($conversion->removePrefixes());
            }
        }
    }

    /**
     * Private function to help us keep track of the best conversion found so far.
     *
     * @param Conversion $newConversion
     * @param float $minErr The least relative error of all the Conversions found so far.
     * @param ?Conversion $best The conversion with the least relative error found so far.
     * @return void
     */
    private function testNewConversion(Conversion $newConversion, float &$minErr, ?Conversion &$best): void
    {
        // Let's see if we have a new best.
        if ($newConversion->factor->relativeError < $minErr) {
            $minErr = $newConversion->factor->relativeError;
            $best = $newConversion;
        }
    }

    /**
     * Generate the next best conversion by traversing the conversion graph.
     *
     * Uses a best-first search strategy to find new conversions by:
     * - Inverting existing conversions (if a→b exists, compute b→a)
     * - Composing conversions through intermediate units (if a→c and c→b exist, compute a→b)
     *
     * Selects the conversion with the lowest relative error to add to the matrix.
     * Error scores guide the search toward shorter, more accurate paths.
     *
     * @return bool True if a new conversion was found and added, false if none could be found.
     */
    private function findNextConversion(): bool
    {
        // Prep.
        $minErr = PHP_FLOAT_MAX;
        $best = null;

        // Iterate through all possible pairs of unit terms.
        foreach ($this->unitTerms as $srcUnitTerm) {
            foreach ($this->unitTerms as $destUnitTerm) {
                $src = $srcUnitTerm->symbol;
                $dest = $destUnitTerm->symbol;

                // If we don't need this conversion, or it's already known, continue.
                if ($src === $dest || isset($this->conversions[$src][$dest])) {
                    continue;
                }

                // Look for the inverse conversion.
                if (isset($this->conversions[$dest][$src])) {
                    $newConversion = $this->conversions[$dest][$src]->invert();
                    $this->testNewConversion($newConversion, $minErr, $best);
                }

                // Look for a conversion opportunity via an intermediate unit.
                foreach ($this->unitTerms as $midUnitTerm) {
                    $mid = $midUnitTerm->symbol;

                    // The intermediate unit must be different from the source and destination units.
                    if ($src === $mid || $dest === $mid) {
                        continue;
                    }

                    // Get conversions between the source, destination, and intermediate unit.
                    $srcToMid = $this->conversions[$src][$mid] ?? null;
                    $midToSrc = $this->conversions[$mid][$src] ?? null;
                    $destToMid = $this->conversions[$dest][$mid] ?? null;
                    $midToDest = $this->conversions[$mid][$dest] ?? null;

                    // Combine source->mid with mid->dest (sequential).
                    if ($srcToMid !== null && $midToDest !== null) {
                        $newConversion = $srcToMid->combineSequential($midToDest);
                        $this->testNewConversion($newConversion, $minErr, $best);
                    }

                    // Combine source->mid with dest->mid (convergent).
                    if ($srcToMid !== null && $destToMid !== null) {
                        $newConversion = $srcToMid->combineConvergent($destToMid);
                        $this->testNewConversion($newConversion, $minErr, $best);
                    }

                    // Combine mid->source with mid->dest (divergent).
                    if ($midToSrc !== null && $midToDest !== null) {
                        $newConversion = $midToSrc->combineDivergent($midToDest);
                        $this->testNewConversion($newConversion, $minErr, $best);
                    }

                    // Combine mid->source with dest->mid (opposite).
                    if ($midToSrc !== null && $destToMid !== null) {
                        $newConversion = $midToSrc->combineOpposite($destToMid);
                        $this->testNewConversion($newConversion, $minErr, $best);
                    }
                }

                // Look for a conversion by exponentiation.
                if ($srcUnitTerm->exponent > 1 && $srcUnitTerm->exponent === $destUnitTerm->exponent) {
                    $converter = self::getByDimension($srcUnitTerm->unit->dimension);
                    $newConversion = $converter
                        ->getConversion($srcUnitTerm->unit, $destUnitTerm->unit)
                        ->applyExponent($srcUnitTerm->exponent);
                    $this->testNewConversion($newConversion, $minErr, $best);
                }
            }
        }

        if ($best !== null) {
            // Remember the best conversion we found for this scan.
            $this->addConversion($best);

            // Report we found one.
            return true;
        }

        return false;
    }

    /**
     * Get all the unprefixed unit symbols matching the dimension code.
     *
     * These are ASCII symbols because they're for array keys.
     *
     * @return list<string> The unit symbols matching the dimension.
     * @throws DomainException
     */
    private function getUnitSymbolsByDimension(): array
    {
        $symbols = [];
        $units = UnitData::getByDimension($this->dimension);
        foreach ($units as $unit) {
            $symbols[] = $unit->asciiSymbol;
        }

        // If we have a letter plus an exponent greater than 1 (e.g. L2, L3), search for units matching the letter
        // and append the exponent.
        $dimTerms = Dimensions::explode($this->dimension);
        if (count($dimTerms) === 1) {
            $dim = array_key_first($dimTerms);
            $exp = $dimTerms[$dim];
            if ($exp !== 1) {
                $units = UnitData::getByDimension($dim);
                foreach ($units as $unit) {
                    $symbols[] = $unit->asciiSymbol . $exp;
                }
            }
        }

        return $symbols;
    }

    // endregion

    // region Debugging methods

    /**
     * Print the conversion matrix for debugging purposes.
     *
     * @return void
     * @codeCoverageIgnore
     */
    public function printMatrix(): void
    {
        $colWidth = 20;
        $nUnits = count($this->unitTerms);
        $line = '+------+' . str_repeat(str_repeat('-', $colWidth) . '+', $nUnits) . "\n";

        echo $line;
        echo '|      |';
        foreach ($this->unitTerms as $unitTerm) {
            echo str_pad($unitTerm->symbol, $colWidth, ' ', STR_PAD_BOTH) . '|';
        }
        echo "\n";
        echo $line;

        foreach ($this->unitTerms as $srcUnitTerm) {
            echo '|' . str_pad($srcUnitTerm->symbol, 6) . '|';
            foreach ($this->unitTerms as $destUnitTerm) {
                if (isset($this->conversions[$srcUnitTerm->symbol][$destUnitTerm->symbol])) {
                    $mul = $this->conversions[$srcUnitTerm->symbol][$destUnitTerm->symbol]->factor->value;
                    $sMul = sprintf('%.10g', $mul);
                    echo str_pad($sMul, $colWidth);
                } elseif ($srcUnitTerm->symbol === $destUnitTerm->symbol) {
                    echo str_pad('1', $colWidth);
                } else {
                    echo str_pad('?', $colWidth);
                }
                echo '|';
            }
            echo "\n";
        }

        echo $line;
    }

    // endregion
}
