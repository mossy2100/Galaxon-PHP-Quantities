<?php

declare(strict_types=1);

namespace Galaxon\Quantities;

use DomainException;
use Galaxon\Core\Exceptions\FormatException;
use Galaxon\Quantities\Registry\ConversionRegistry;
use Galaxon\Quantities\Registry\DimensionRegistry;
use Galaxon\Quantities\Registry\QuantityTypeRegistry;
use LogicException;

/**
 * Manages unit conversions for a measurement type.
 *
 * This class uses the multiton pattern to maintain a map of dimensions to Converter objects.
 *
 * The class handles:
 * - Validation of base units, prefixes, and conversion definitions
 * - Automatic discovery of indirect conversion paths via graph traversal
 * - Prefix algebra for converting between prefixed units
 *
 * The conversion system works by:
 * 1. Storing direct conversions provided in the configuration
 * 2. Automatically inferring additional conversions through:
 *    - Inversion (if a→b exists, compute b→a)
 *    - Composition (if a→c and c→b exist, compute a→b)
 * 3. Applying prefix adjustments when requested units have prefixes
 *
 * All conversions use the linear transformation formula: y = m*x where m is the multiplier.
 *
 * Error tracking: Each conversion has an error score based on numerical precision.
 * The system prefers shorter conversion paths with lower cumulative error.
 */
class Converter
{
    // region Properties

    /**
     * Dimension code for the converter.
     *
     * @var string
     */
    private(set) string $dimension;

    /**
     * Unprefixed units for this converter.
     *
     * @var array<string, DerivedUnit>
     */
    private(set) array $units = [];

    // endregion

    // region Static properties

    /**
     * All the Converters created so far, keyed by dimension.
     *
     * @var array<string, Converter>
     */
    private static array $instances;

    // endregion

    // region Constructor

    /**
     * Constructor.
     *
     * Initializes the Converter instance for a given dimension.
     *
     * @param string $dimension Dimension code (e.g. 'L', 'MLT-2').
     * @throws FormatException If the dimension code is invalid.
     * @throws DomainException If any conversion definitions are invalid.
     */
    private function __construct(string $dimension)
    {
        // Check the dimension is valid.
        if (!DimensionRegistry::isValid($dimension)) {
            throw new FormatException("Invalid dimension code '$dimension'.");
        }

        // Store the dimension code.
        $this->dimension = $dimension;

        // Load units from the registered conversions for this dimension.
        $conversionsBySrc = ConversionRegistry::getByDimension($dimension);
        foreach ($conversionsBySrc as $conversionsByDest) {
            foreach ($conversionsByDest as $conversion) {
                $this->addUnit($conversion->srcUnit);
                $this->addUnit($conversion->destUnit);
            }
        }

        // Initialize simple conversions.
        $this->findSimpleConversions();
    }

    // endregion

    // region Factory methods

    /**
     * Get the Converter instance for a given dimension.
     *
     * @param string $dimension Dimension code (e.g. 'L').
     * @return self
     * @throws DomainException
     */
    public static function getByDimension(string $dimension): self
    {
        // Make sure a Converter for this dimension has been created.
        if (!isset(self::$instances[$dimension])) {
            self::$instances[$dimension] = new self($dimension);
        }

        return self::$instances[$dimension];
    }

    // endregion

    // region Conversion methods

    /**
     * Find the conversion between two unit terms.
     *
     * Returns the Conversion object representing the transformation from source to destination unit term.
     * The conversion may be:
     * - A unity conversion (factor 1.0) if units are identical
     * - Retrieved from the ConversionRegistry if previously computed
     * - A prefix-only adjustment if units share the same base
     * - Generated by pathfinding through the conversion matrix
     *
     * Generated conversions are cached for future use.
     *
     * @param string|UnitInterface $srcUnit The source unit.
     * @param string|UnitInterface $destUnit The destination unit.
     * @return ?Conversion The conversion transformation or null if none found.
     * @throws DomainException If either unit term is invalid.
     * @example
     *   $conversion = $converter->getConversion('m', 'ft');
     */
    public function getConversion(string|UnitInterface $srcUnit, string|UnitInterface $destUnit): ?Conversion
    {
        // Validate the units and convert to DerivedUnit objects.
        $srcUnit = $this->validateUnit($srcUnit);
        $destUnit = $this->validateUnit($destUnit);

        // Handle the simple case.
        if ($srcUnit->equal($destUnit)) {
            return new Conversion($srcUnit, $destUnit, 1.0);
        }

        // Make sure both unit terms (unprefixed) are in the converter.
        $this->addUnit($srcUnit);
        $this->addUnit($destUnit);

        // See if we already have this one.
        $conversion = ConversionRegistry::get($this->dimension, $srcUnit->asciiSymbol, $destUnit->asciiSymbol);
        if ($conversion !== null) {
            return $conversion;
        }

        // Find the conversion between unprefixed units.
        $dim = $this->dimension;
        $src = $srcUnit->removePrefixes()->asciiSymbol;
        $dest = $destUnit->removePrefixes()->asciiSymbol;

        // Generate new conversions until we get a match, or we're out of options.
        do {
            $result = $this->findNextConversion();
            $unprefixedConversion = ConversionRegistry::get($dim, $src, $dest);
        } while ($unprefixedConversion === null && $result);

        // If we couldn't find an unprefixed conversion, return null.
        if ($unprefixedConversion === null) {
            return null;
        }

        // Apply prefixes if necessary.
        if ($srcUnit->hasPrefixes() || $destUnit->hasPrefixes()) {
            // Construct the conversion with the conversion factor determined from the prefixes.
            $factor = $unprefixedConversion->factor->mul($srcUnit->multiplier)->div($destUnit->multiplier);
            $conversion = new Conversion($srcUnit, $destUnit, $factor);

            // Add the new prefixed conversion to the Converter.
            ConversionRegistry::addConversion($conversion);

            // Return it.
            return $conversion;
        }

        // No prefixes; return the unprefixed conversion.
        return $unprefixedConversion;
    }

    /**
     * Get the conversion factor between two unit terms.
     *
     * @param string|UnitInterface $srcUnit The source unit.
     * @param string|UnitInterface $destUnit The destination unit.
     * @return ?float The conversion factor or null if not found.
     * @throws DomainException If either unit term is invalid.
     */
    public function getConversionFactor(string|UnitInterface $srcUnit, string|UnitInterface $destUnit): ?float
    {
        return $this->getConversion($srcUnit, $destUnit)?->factor->value;
    }

    /**
     * Convert a numeric value from one unit to another.
     *
     * Validates both unit symbols, retrieves or computes the conversion, and applies it to the value using the formula
     * y = m*x
     *
     * @param float $value The value to convert.
     * @param string|UnitInterface $srcUnit The source unit.
     * @param string|UnitInterface $destUnit The destination unit.
     * @return float The converted value.
     * @throws DomainException If either unit symbol is invalid.
     * @throws LogicException If no conversion path exists between the units.
     *
     * @example
     *   $meters = 100;
     *   $feet = $converter->convert($meters, 'm', 'ft');  // 328.084
     */
    public function convert(float $value, string|UnitInterface $srcUnit, string|UnitInterface $destUnit): float
    {
        // Get the conversion.
        $conversion = $this->getConversion($srcUnit, $destUnit);

        // If no conversion was found, throw an exception.
        if ($conversion === null) {
            throw new LogicException("No conversion found between units '$srcUnit' and '$destUnit'.");
        }

        // Multiply by the conversion factor.
        return $value * $conversion->factor->value;
    }

    // endregion

    // region Modification methods

    /**
     * Remove prefixes and add the unit to the Converter.
     *
     * @param DerivedUnit $derivedUnit The unit to add.
     */
    public function addUnit(DerivedUnit $derivedUnit): void
    {
        // Add the unprefixed unit to the converter.
        $unprefixedUnit = $derivedUnit->removePrefixes();
        $this->units[$unprefixedUnit->asciiSymbol] = $unprefixedUnit;

        // Add the merged unit to the converter, if different.
        $this->addMergedUnit($derivedUnit);

        // Add the expanded unit to the converter, if different.
        $this->addExpandedUnit($derivedUnit);
    }

    // endregion

    // region Validation methods

    /**
     * Validate a string or object representing a unit.
     *
     * Returns the validated DerivedUnit object if valid, and throws an exception if not.
     *
     * @param string|UnitInterface $value The unit value to validate.
     * @return DerivedUnit The validated DerivedUnit object equivalent to the provided parameter.
     * @throws DomainException If the symbol is invalid or the unit has the wrong dimension for this Converter.
     */
    public function validateUnit(string|UnitInterface $value): DerivedUnit
    {
        // Get the unit term as a DerivedUnit object.
        $unit = DerivedUnit::toDerivedUnit($value);

        // Check the unit term has the right dimension.
        if ($unit->dimension !== $this->dimension) {
            $qtyType = QuantityTypeRegistry::getByDimension($this->dimension);
            $error = $qtyType === null
                ? "The unit dimension '$unit->dimension' does not match the converter dimension '$this->dimension'."
                : "The unit '$unit->asciiSymbol' is invalid for $qtyType->name quantities.";
            throw new DomainException($error);
        }

        return $unit;
    }

    // endregion

    // region Helper methods for finding conversions

    /**
     * Private function to help us keep track of the best conversion found so far.
     *
     * @param Conversion $newConversion The new conversion to test.
     * @param float $minErr The least relative error of all the Conversions found so far.
     * @param ?Conversion $best The conversion with the least relative error found so far.
     * @param bool $done If we can stop looking because the error is zero.
     * @return void
     */
    private static function testNewConversion(
        Conversion $newConversion,
        float &$minErr,
        ?Conversion &$best,
        bool &$done
    ): void {
        // Let's see if we have a new best.
        if ($newConversion->factor->relativeError < $minErr) {
            $minErr = $newConversion->factor->relativeError;
            $best = $newConversion;
            $done = $minErr === 0.0;
        }
    }

    /**
     * Attempt to generate a conversion by exponentiating a base conversion.
     *
     * If both units are single-term with the same exponent > 1 (e.g., m² → ft²), finds the conversion between the base
     * units (m → ft) and raises it to the exponent.
     *
     * @param DerivedUnit $srcUnit The source unit.
     * @param DerivedUnit $destUnit The destination unit.
     * @return ?Conversion The exponentiated conversion, or null if not applicable.
     */
    private static function getConversionByExponentiation(DerivedUnit $srcUnit, DerivedUnit $destUnit): ?Conversion
    {
        // Make sure both derived units have only one unit term.
        if (count($srcUnit->unitTerms) !== 1 || count($destUnit->unitTerms) !== 1) {
            return null;
        }

        // Check they have the same exponent, and it's not equal to 1.
        /** @var UnitTerm $srcUnitTerm */
        $srcUnitTerm = $srcUnit->firstUnitTerm;
        /** @var UnitTerm $destUnitTerm */
        $destUnitTerm = $destUnit->firstUnitTerm;
        if (
            $srcUnitTerm->exponent === 1 ||
            $destUnitTerm->exponent === 1 ||
            $srcUnitTerm->exponent !== $destUnitTerm->exponent
        ) {
            return null;
        }

        // Remove the exponents.
        $unexponentiatedSrcUnit = $srcUnitTerm->removeExponent();
        $unexponentiatedDestUnit = $destUnitTerm->removeExponent();

        // Get the converter between unexponentiated units.
        $converter = self::getByDimension($unexponentiatedSrcUnit->dimension);
        $conversion = $converter->getConversion($unexponentiatedSrcUnit, $unexponentiatedDestUnit);

        // Return the conversion raised to the exponent.
        return $conversion?->pow($srcUnitTerm->exponent);
    }

    /**
     * Attempt to generate a conversion by converting each unit term individually.
     *
     * For compound units with multiple terms (e.g., kg·m·s⁻² → lb·ft·s⁻²), finds the conversion for each corresponding
     * pair of unit terms and multiplies the factors together.
     *
     * @param DerivedUnit $srcUnit The source unit.
     * @param DerivedUnit $destUnit The destination unit.
     * @return ?Conversion The combined conversion, or null if not applicable or no path exists.
     */
    private static function getConversionByTerms(DerivedUnit $srcUnit, DerivedUnit $destUnit): ?Conversion
    {
        // Check number of unit terms match.
        if (count($srcUnit->unitTerms) !== count($destUnit->unitTerms)) {
            return null;
        }

        // Check we have at least 2 unit terms each.
        if (count($srcUnit->unitTerms) < 2) {
            return null;
        }

        // Generate conversion factor by multiplying the factors for each term.
        $srcUnitTerms = array_values($srcUnit->unitTerms);
        $destUnitTerms = array_values($destUnit->unitTerms);
        $factor = new FloatWithError(1);
        foreach ($srcUnitTerms as $i => $srcUnitTerm) {
            $destUnitTerm = $destUnitTerms[$i];

            // Check the dimensions match.
            if ($srcUnitTerm->dimension !== $destUnitTerm->dimension) {
                return null;
            }

            // Get the conversion.
            $converter = self::getByDimension($srcUnitTerm->dimension);
            $conversion = $converter->getConversion($srcUnitTerm, $destUnitTerm);
            if ($conversion === null) {
                return null;
            }

            // Multiply.
            $factor = $factor->mul($conversion->factor);
        }

        return new Conversion($srcUnit, $destUnit, $factor);
    }

    /**
     * Generate the next best conversion by traversing the conversion graph.
     *
     * Uses a best-first search strategy to find new conversions by:
     * - Inverting existing conversions (if a→b exists, compute b→a)
     * - Composing conversions through intermediate units (if a→c and c→b exist, compute a→b)
     *
     * Selects the conversion with the lowest relative error to add to the matrix.
     * Error scores guide the search toward shorter, more accurate paths.
     *
     * @return bool True if a new conversion was found and added, false if none could be found.
     */
    private function findNextConversion(): bool
    {
        // Prep.
        $dim = $this->dimension;
        $minErr = PHP_FLOAT_MAX;
        $best = null;
        $done = false;

        // Iterate through all possible pairs of units.
        foreach ($this->units as $srcUnit) {
            foreach ($this->units as $destUnit) {
                $src = $srcUnit->asciiSymbol;
                $dest = $destUnit->asciiSymbol;

                // Skip identity conversions and those already known.
                if ($src === $dest || ConversionRegistry::has($dim, $src, $dest)) {
                    continue;
                }

                // Look for the inverse conversion.
                $inverse = ConversionRegistry::get($dim, $dest, $src);
                if ($inverse !== null) {
                    $newConversion = $inverse->inv();
                    self::testNewConversion($newConversion, $minErr, $best, $done);
                    if ($done) {
                        break 2;
                    }
                }

                // Look for a conversion opportunity via an intermediate unit.
                foreach ($this->units as $midUnit) {
                    $mid = $midUnit->asciiSymbol;

                    // The intermediate unit must be different from the source and destination units.
                    if ($src === $mid || $dest === $mid) {
                        continue;
                    }

                    // Get conversions between the source, destination, and intermediate unit.
                    $srcToMid = ConversionRegistry::get($dim, $src, $mid);
                    $midToSrc = ConversionRegistry::get($dim, $mid, $src);
                    $destToMid = ConversionRegistry::get($dim, $dest, $mid);
                    $midToDest = ConversionRegistry::get($dim, $mid, $dest);

                    // Combine source->mid with mid->dest (sequential).
                    if ($srcToMid !== null && $midToDest !== null) {
                        $newConversion = $srcToMid->combineSequential($midToDest);
                        self::testNewConversion($newConversion, $minErr, $best, $done);
                        if ($done) {
                            break 3;
                        }
                    }

                    // Combine source->mid with dest->mid (convergent).
                    if ($srcToMid !== null && $destToMid !== null) {
                        $newConversion = $srcToMid->combineConvergent($destToMid);
                        self::testNewConversion($newConversion, $minErr, $best, $done);
                        if ($done) {
                            break 3;
                        }
                    }

                    // Combine mid->source with mid->dest (divergent).
                    if ($midToSrc !== null && $midToDest !== null) {
                        $newConversion = $midToSrc->combineDivergent($midToDest);
                        self::testNewConversion($newConversion, $minErr, $best, $done);
                        if ($done) {
                            break 3;
                        }
                    }

                    // Combine mid->source with dest->mid (opposite).
                    if ($midToSrc !== null && $destToMid !== null) {
                        $newConversion = $midToSrc->combineOpposite($destToMid);
                        self::testNewConversion($newConversion, $minErr, $best, $done);
                        if ($done) {
                            break 3;
                        }
                    }
                }

                // Look for a conversion by exponentiation.
                $newConversion = self::getConversionByExponentiation($srcUnit, $destUnit);
                if ($newConversion !== null) {
                    self::testNewConversion($newConversion, $minErr, $best, $done);
                    if ($done) {
                        break 2;
                    }
                }

                // Look for a conversion by multiple unit terms.
                $newConversion = self::getConversionByTerms($srcUnit, $destUnit);
                if ($newConversion !== null) {
                    self::testNewConversion($newConversion, $minErr, $best, $done);
                    if ($done) {
                        break 2;
                    }
                }
            }
        }

        if ($best !== null) {
            // Remember the best conversion we found for this scan.
            ConversionRegistry::addConversion($best);
            // echo $best, ' ', $minErr, PHP_EOL;

            // Report we found one.
            return true;
        }

        return false;
    }

    /**
     * Generate all simple conversions, including:
     * - Unity conversions
     * - Combinations requiring integer multiplications only
     */
    private function findSimpleConversions(): void
    {
        // Prep.
        $dim = $this->dimension;

        // Loop until no more new conversions are found.
        do {
            $foundNew = false;

            // Iterate through all possible pairs of units.
            foreach ($this->units as $srcUnit) {
                foreach ($this->units as $destUnit) {
                    $src = $srcUnit->asciiSymbol;
                    $dest = $destUnit->asciiSymbol;

                    // If this conversion is already known, continue.
                    if (ConversionRegistry::has($dim, $src, $dest)) {
                        continue;
                    }

                    // Look for identity conversions.
                    if ($src === $dest) {
                        $newConversion = new Conversion($srcUnit, $destUnit, 1);
                        ConversionRegistry::addConversion($newConversion);
                        $foundNew = true;
                        continue;
                    }

                    // Look for conversion opportunity via an intermediate unit involving only integer multiplications.
                    foreach ($this->units as $midUnit) {
                        $mid = $midUnit->asciiSymbol;

                        // The intermediate unit must be different from the source and destination units.
                        if ($src === $mid || $dest === $mid) {
                            continue;
                        }

                        // Get conversions between the source, destination, and intermediate unit.
                        $srcToMid = ConversionRegistry::get($dim, $src, $mid);
                        $midToDest = ConversionRegistry::get($dim, $mid, $dest);

                        // If the conversions exist and the factors are integers, combine source->mid with mid->dest
                        // (sequential).
                        if (
                            $srcToMid !== null &&
                            $midToDest !== null &&
                            $srcToMid->factor->isInteger() &&
                            $midToDest->factor->isInteger()
                        ) {
                            $newConversion = $srcToMid->combineSequential($midToDest);
                            ConversionRegistry::addConversion($newConversion);
                            $foundNew = true;
                        }
                    }
                }
            }
        } while ($foundNew);
    }

    // endregion

    // region Helper methods for adding unit terms

    /**
     * Merges compatible units.
     *
     * If this creates a new unit, add it to the Converter.
     * Also generates a new conversion and adds it to the ConversionRegistry.
     *
     * @param DerivedUnit $unit The unit to check and potentially add a merged variant for.
     * @return void
     */
    private function addMergedUnit(DerivedUnit $unit): void
    {
        // Check if there's anything to do.
        if (!$unit->hasMergeableUnits()) {
            return;
        }

        // Generate the merged unit.
        $qty = Quantity::create(1, $unit)->merge();

        // Add the merged unit to the Converter.
        $this->addUnit($qty->derivedUnit);

        // Add the new conversion to the registry.
        ConversionRegistry::addConversion(new Conversion($unit, $qty->derivedUnit, $qty->value));
    }

    /**
     * Expands a unit and adds it to the Converter.
     *
     * If the unit has an expansion, generates the expanded form, adds it to the Converter,
     * and registers a conversion between the original and expanded units.
     *
     * @param DerivedUnit $unit The unit to check and potentially add an expanded variant for.
     * @return void
     */
    private function addExpandedUnit(DerivedUnit $unit): void
    {
        // Check if there's anything to do.
        if (!$unit->hasExpansion()) {
            return;
        }

        // Generate the expansion quantity.
        $qty = Quantity::create(1, $unit)->expand()->merge();

        // Add the expanded unit to the Converter.
        $this->addUnit($qty->derivedUnit);

        // Add the new conversion to the registry.
        ConversionRegistry::addConversion(new Conversion($unit, $qty->derivedUnit, $qty->value));
    }

    // endregion

    // region Debugging methods

    /**
     * Print the conversion matrix for debugging purposes.
     *
     * @return void
     * @codeCoverageIgnore
     */
    public function printMatrix(): void
    {
        $colWidth = 20;
        $nUnits = count($this->units);
        $line = '+' . str_repeat('-', $colWidth) . '+' .
            str_repeat(str_repeat('-', $colWidth) . '+', $nUnits) . "\n";

        echo $line;
        echo '|' . str_repeat(' ', $colWidth) . '|';
        foreach ($this->units as $unitTerm) {
            echo str_pad($unitTerm->asciiSymbol, $colWidth, ' ', STR_PAD_BOTH) . '|';
        }
        echo "\n";
        echo $line;

        foreach ($this->units as $srcUnit) {
            echo '|' . str_pad($srcUnit->asciiSymbol, $colWidth) . '|';
            foreach ($this->units as $destUnit) {
                $conversion = ConversionRegistry::get($this->dimension, $srcUnit->asciiSymbol, $destUnit->asciiSymbol);

                if ($conversion !== null) {
                    $mul = $conversion->factor->value;
                    $sMul = sprintf('%.10g', $mul);
                    echo str_pad($sMul, $colWidth);
                } elseif ($srcUnit->asciiSymbol === $destUnit->asciiSymbol) {
                    echo str_pad('1', $colWidth);
                } else {
                    echo str_pad('?', $colWidth);
                }

                echo '|';
            }
            echo "\n";
        }

        echo $line;
    }

    /**
     * Generate all possible conversions between units in this converter.
     *
     * Repeatedly calls findNextConversion() until no more conversions can be discovered.
     * Useful for debugging or pre-populating the conversion matrix.
     *
     * @return void
     * @codeCoverageIgnore
     */
    public function completeMatrix(): void
    {
        do {
            $result = $this->findNextConversion();
        } while ($result);
    }

    // endregion
}
